package com.elster.jupiter.hsm.integration.helpers;

import com.elster.jupiter.hsm.integration.helpers.keys.AsymmetricKey;
import com.elster.jupiter.hsm.integration.helpers.keys.Encoder;
import com.elster.jupiter.hsm.model.Message;
import com.elster.jupiter.hsm.model.krypto.AsymmetricAlgorithm;
import com.elster.jupiter.hsm.model.krypto.SymmetricAlgorithm;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Base64;

import org.junit.Ignore;
import org.junit.Test;

/**
 * This is just a helper to decrypt keys in import file therefore not a proper test -> ignore it and run it manually
 */
@Ignore
public class DecryptImportSampleTest {


    public static final int IV_LENGTH = 16;

    @Test
    public void decrypt() throws
            NoSuchPaddingException,
            NoSuchAlgorithmException,
            IllegalBlockSizeException,
            BadPaddingException,
            InvalidKeyException,
            InvalidKeySpecException,
            IOException,
            InvalidAlgorithmParameterException {

        String base64PublicWrapperKey ="30820122300D06092A864886F70D01010105000382010F003082010A0282010100C39BF855C439F7AF9510112E86229927E7381C1FC43FE8C2FCB0F092F0DAA4EDFF036F7517833338EC634BA7756AC42FAEE729DC148E108E1B9804AFA1D54295436FB7A78950A66C36528705E52431BCA5E7EDD56DECF6A39583527F7796DF9000E918179BC85D063D3948FDFA1FD5669C329CC112BAD48CDFCE8736B8886C4C2D1F1BE302D9DC3C5BE76E0EA957B0543559E5D48CC5270EB3B8DBD716827934A14FA8238387E9A1F8722DC235AAE156B9221B2B96B83095D8DC8FBC9F7A7434C949A6D1DB4FAC45F72E97D4EBBB39F68EF2FE78E1CEABA4C1F60BF779E762C3FE729982A938FB00DC70F4A4125398339B3B076F2163E2CC795D9963E97BCBCF0203010001";
        String base64PrivateWrapperKey = "308204BE020100300D06092A864886F70D0101010500048204A8308204A40201000282010100C39BF855C439F7AF9510112E86229927E7381C1FC43FE8C2FCB0F092F0DAA4EDFF036F7517833338EC634BA7756AC42FAEE729DC148E108E1B9804AFA1D54295436FB7A78950A66C36528705E52431BCA5E7EDD56DECF6A39583527F7796DF9000E918179BC85D063D3948FDFA1FD5669C329CC112BAD48CDFCE8736B8886C4C2D1F1BE302D9DC3C5BE76E0EA957B0543559E5D48CC5270EB3B8DBD716827934A14FA8238387E9A1F8722DC235AAE156B9221B2B96B83095D8DC8FBC9F7A7434C949A6D1DB4FAC45F72E97D4EBBB39F68EF2FE78E1CEABA4C1F60BF779E762C3FE729982A938FB00DC70F4A4125398339B3B076F2163E2CC795D9963E97BCBCF02030100010282010100912DF4BDAB3B1ED3297E58524069F364435F48B8670ECBF1D45C7AE18473B2CF9562F659608F16F85BB242D751F56110C6EE790A08137CC40C44E2CD7BFE6D419D60905D7F33E5A1111C656C81AA4063F47AD3F18179CB80941A78A3749DFCE5C3573D736042F0900DE6B37F1522855F77F4B49534128868DA3F4DE9D64222A586CD269AB972F20ED779024F2D400FE11A37F29ED0BE9628DF36D51C3FCD05958CBDA5A2F6098F15325C58960D1A478C56DD4EF04E83E537CC0A6F83CD703305E0F109B0F4A1BFD3964D59F4755FECCCAE916DE9041B5B3BCED82C66A131E0B52F51904907B5F476DA2EC715FFCF64A161DA7B8F8082B73DDBC385A351102FD102818100E6E5CD87459F824AE9E90EBC4176D6902FBBDFD5745F3B776F3A216D3FA95164A1976FF7D9751591168A62EC759631C6411ABA1E2FCD908B828E9B6634B28D706857AA4D11964427C08CFF2B63156D2B5BA930D9FDE3C85A9BEFBA0F1D9E156F91D19FDD487FE8D1F7A1A43EC01A3F63C9D96347AB94A84FA76DACFA4BA8E7F902818100D8E00AE9BC689C628FAC3A5259A6AABD4FA042D553691C3562260B48F77A4D84ECD04E70CA7C66362B37846C7DAF897E51D78CAF60101D8201CA0B303FEDD9D1D0C101503965AE0118F8111FB96F21BB1D51DA6854036565897B0AE64E05533551CF440A96172045FC11B615977FDD3C8F7BC5249CCD61E7A0DCCE546F2E140702818100DF4438CFE3CFD08235DAA8E7FA793A126445CBB3B07A619B248F5641387CB5FA939246AFA7B362AE4FD872BD691A5978F5FD2D19016A49A9CD0DAE504F069463AC51909843384521173C7F84E9A38F538CA7765863FB3D01F8A4FF099CBEFEC54A8023902A899C8C636206DAB290EED8C41693BC7ABA1D6220689A09D0DD3BA9028180042DF527E200A61AE427EE8BCDBC7F87DC73FB35BF40C451670DD2A3DA591A0B58C0FEF1FF84FC374907EDDE6561AFA5A6901FDEF55BFA259A41398BF97F6CF6352EB306C7C464E112891D535E307D16ED0EB9C5CEF0ADD09220B3EA1250D9F4AA19F376BCC3BF5479F2216F33173CBD410AA296FD0A9C3B698737D6BAB9C99B0281804AEFFD1D288702C6A74AAC8AD77B8769E3EF04FB6C9AD0F3671BB1B3CD8D18538109DD698B87A4F51D975C96B4F97B64E111B8DD4D1A47D19FFB3EBA526A44FB5F47DC4FCB44EA2CB689511DBCD89F01F501FD06FFF7C91A7376275D4D5AA9DDE6BA67EF4334D0D4BC634EEFA65F128A7A7C66BDE9A5DA2C890F2392E90DDAAB";
        AsymmetricKey key = new AsymmetricKey(base64PublicWrapperKey, base64PrivateWrapperKey, Encoder.HEX);

        RSAEncryptionHelper rsaEncryptionHelper = new RSAEncryptionHelper();
        Message encryptedWrapperKey = new Message(Base64.getDecoder().decode("Epja6wa/Q252mV/6hIdQuOgVzg3Qu5sqhwqZMMDJbyAWg7LEnl2ux9cCtRWmooO6XibWmCjjGUM5bCZd8nf16vKLO3+vLPVgUBMLNdvHbofN+LcfErqIeTPC4JrjjLp7GLNsqFr6uWp7lOJIvTxK7893ku0VQ1lIANZdlcNqEjwWe8EmzO0el3yr19NdBYyUUYh/tI6AHm/TISdPIRe5Ky4bHoor9OBnVYAt7oaa1aLib0AjXFfLuS8LxAgMfBQDk405FNRX7o/qbkVEKuhIfxUAfNTLz3iC2ZJ80LtTxZ5OzBHF3PTcML22ILiWHvWblLRUJvvovHbemMgrAl06Sg=="));
        Message decryptedWrapperKey = rsaEncryptionHelper.decrypt(encryptedWrapperKey, AsymmetricAlgorithm.RSA_15, key);


        String base64DevicePassword = "MDEyMzQ1Njc4OUFCQ0RFRvb34cKxnOndxM3ElgEpi1mSnZ9WQO04/9S2IzEWNFDj";
        Message encDevicePassword = new Message(Base64.getDecoder().decode(base64DevicePassword));


        AESEncryptionHelper aesEncryptionHelper = new AESEncryptionHelper();
        Message deviceKeyDecrypted = aesEncryptionHelper.decrypt(getCipher(encDevicePassword), decryptedWrapperKey, getInitializationVector(encDevicePassword), SymmetricAlgorithm.AES_256_CBC);

        System.out.println("Device key:" + deviceKeyDecrypted);
        System.out.println("Device key (HEX):" + deviceKeyDecrypted.toHex());
        System.out.println("Device key (BASE64):" + deviceKeyDecrypted.toBase64());

    }

    public Message getCipher(Message encryptedMessage) {
        byte[] encryptedKey = encryptedMessage.getBytes();
        byte[] cipher = new byte[encryptedKey.length - IV_LENGTH];
        System.arraycopy(encryptedKey, IV_LENGTH, cipher, 0, encryptedKey.length - IV_LENGTH);
        return new Message(cipher);
    }

    public Message getInitializationVector(Message encryptedKey){
        byte[] initializationVector = new byte[IV_LENGTH];
        System.arraycopy(encryptedKey.getBytes(), 0, initializationVector, 0, IV_LENGTH);
        return new Message(initializationVector);
    }

}
