/*
 * Copyright (c) 2017 by Honeywell Inc. All rights reserved.
 */

package com.elster.jupiter.pki.impl.wrappers.asymmetric;

import com.elster.jupiter.datavault.DataVaultService;
import com.elster.jupiter.nls.NlsMessageFormat;
import com.elster.jupiter.nls.Thesaurus;
import com.elster.jupiter.orm.DataModel;
import com.elster.jupiter.pki.KeyAccessorType;
import com.elster.jupiter.pki.KeyType;
import com.elster.jupiter.properties.PropertySpecService;
import com.elster.jupiter.util.exception.MessageSeed;

import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey;
import org.bouncycastle.jce.ECNamedCurveTable;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.jce.spec.ECNamedCurveParameterSpec;

import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.util.Base64;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * Created by bvn on 3/10/17.
 */
@RunWith(MockitoJUnitRunner.class)
public class PlaintextEcdsaPrivateKeyTest {
    @Mock
    PropertySpecService propertySpecService;
    @Mock
    Thesaurus thesaurus;
    @Mock
    DataVaultService datavaultService;
    @Mock
    DataModel dataModel;

    KeyType keyType;
    PlaintextEcdsaPrivateKey privateKeyWrapper;

    @Before
    public void setUp() throws Exception {
        Security.addProvider(new BouncyCastleProvider());
        when(datavaultService.encrypt(any())).then(invocationOnMock -> Base64.getEncoder().encodeToString((byte[]) invocationOnMock.getArguments()[0]));
        when(datavaultService.decrypt(any())).then(invocationOnMock -> Base64.getDecoder().decode((String)invocationOnMock.getArguments()[0]));
        ValidatorFactory validatorFactory = mock(ValidatorFactory.class);
        when(dataModel.getValidatorFactory()).thenReturn(validatorFactory);
        Validator validator = mock(Validator.class);
        when(validatorFactory.getValidator()).thenReturn(validator);
        NlsMessageFormat format = mock(NlsMessageFormat.class);
        when(thesaurus.getFormat(any(MessageSeed.class))).thenReturn(format);
        KeyAccessorType keyAccessorType = mock(KeyAccessorType.class);
        keyType = mock(KeyType.class);
        when(keyAccessorType.getKeyType()).thenReturn(keyType);
        when(keyType.getKeyAlgorithm()).thenReturn("ECDSA");
        when(keyType.getCurve()).thenReturn("secp256r1");
        privateKeyWrapper = new PlaintextEcdsaPrivateKey(datavaultService, propertySpecService, dataModel, thesaurus);
        privateKeyWrapper.init(keyAccessorType);
    }

    @Test
    public void testVerifyAutoGeneratedPublicKey() throws Exception {
        privateKeyWrapper.generateValue();

        PublicKey publicKey = privateKeyWrapper.getPublicKey();

        assertThat(publicKey.getAlgorithm()).isEqualTo("ECDSA");
        assertThat(publicKey.getFormat()).isEqualTo("X.509");
    }

    @Test
    public void testVerifyManualPublicKey() throws Exception {
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("ECDSA", "BC");
        ECNamedCurveParameterSpec parameterSpec = ECNamedCurveTable.getParameterSpec(keyType.getCurve());
        keyGen.initialize(parameterSpec, new SecureRandom());
        KeyPair keyPair = keyGen.generateKeyPair();
        PrivateKey privateKey = keyPair.getPrivate();

        privateKeyWrapper.setPrivateKey(privateKey);

        BCECPublicKey calculatedPublicKey = (BCECPublicKey) privateKeyWrapper.getPublicKey();
        BCECPublicKey originalPublicKey = (BCECPublicKey) keyPair.getPublic();

        assertThat(calculatedPublicKey.getQ()).isEqualTo(originalPublicKey.getQ());
        assertThat(calculatedPublicKey.getFormat()).isEqualTo(originalPublicKey.getFormat());
        assertThat(calculatedPublicKey.getAlgorithm()).isEqualTo(originalPublicKey.getAlgorithm());
        assertThat(calculatedPublicKey.getW()).isEqualTo(originalPublicKey.getW());
        assertThat(calculatedPublicKey).isEqualTo(originalPublicKey);
    }
}
