package com.elster.jupiter.pki;

/*
 * Copyright (c) 2017 by Honeywell Inc. All rights reserved.
 */
import com.elster.jupiter.util.HasId;
import com.elster.jupiter.util.HasName;

import aQute.bnd.annotation.ProviderType;

import java.security.PublicKey;
import java.util.Optional;

/**
 * This object represents a keypair stored in Connexo, representing a public key and/or private key, without certificate. It contains
 * - a private key, if a private key was generated in Connexo or imported from an external system (see Key Encryption Methods)
 * - a public key, either generated by Connexo or imported from file.
 */
@ProviderType
public interface KeypairWrapper extends HasDynamicPropertiesWithUpdatableValues, HasId, SecurityValueWrapper, HasName {
    /**
     * A keypair alias is the name given to a keypair located in the key store.
     * Each entry in the key store has an alias to help identify it.
     * @return This keypair's alias
     */
    String getAlias();

    /**
     * Set the alias for this keypair.
     * A keypair alias is the name given to a keypair located in the key store.
     * A keypair alias is unique in the store.
     * @param alias
     */
    void setAlias(String alias);

    /**
     * Returns the public key if the keypair contains a public key, false otherwise.
     * A public key might not be available if we import an HSM private key: we might not (yet) have the public key and
     * won't be able to calculate it.
     * @return Public key if available, Optional.empty() otherwise.
     */
    Optional<PublicKey> getPublicKey();

    /**
     * Returns the private key wrapper, is present. PrivateKeyWrapper will only be present if the keypair was created with
     * a wrapper, it can not be added afterwards. // TODO: Should I always create a PrivateKeyWrapper?
     * Caution: the presence of a private key wrapper does not imply the existence of a
     * private key.
     * The Wrapper is explicitly exposed because the user might need access to the properties.
     */
    Optional<PrivateKeyWrapper> getPrivateKeyWrapper();

    /**
     * Returns the KeyType describing the key(s) contained in the keypair, depending on the algorithm, different values
     * can apply, depending on key algorithm, e.g. key length, curve, ...
     * @return The KeyType applicable for this keypair, describing key algorithm and other applicable properties, e.g. key length, curve, ...
     */
    KeyType getKeyType();

    /**
     * Attempts to convert the bytes to public key of the correct type and sets the public key.
     * This method overwrites an existing public key.
     * If a private key is present, the public key is matched with the private key
     * @param key the key, which is assumed to be encoded according to the X.509 standard.
     */
    void setPublicKey(byte[] key);

    /**
     * Sets the public key value for this keypair. This method overwrites an existing public key.
     * If a private key is present, the public key is matched with the private key
     * @param publicKey
     */
    void setPublicKey(PublicKey publicKey);

    /**
     * The current version of this business object. Version property is used for concurrency purposes.
     */
    long getVersion();

    /**
     * Deletes this wrapper and the contained keypair, including private key, if applicable.
     */
    void delete();

    /**
     * Persist changes to this object
     */
    void save();

    /**
     * returns true is this keypair contains a private key, false otherwise.
     */
    boolean hasPrivateKey();

    /**
     * Returns the key encryption method, if present. A key encryption method will not be present if the wrapper only contains a public key.
     * @return Key encryption method, if present.
     */
    Optional<String> getKeyEncryptionMethod();

    /**
     * Allows the generation of a random value for an empty wrapper, in this case, an asymmetric key.
     * Any existing value will be overwritten.
     * It's up to the implementing class to make sure all renewal information is available (through linking
     * KeyTypes/KeyAccessorTypes)
     * Note that not all key encryption methods might permit automatic renewal.
     */
    public void generateValue();


}
