package com.energyict.protocolimplv2.nta.dsmr23.messages;

import com.energyict.common.CommonCryptoMessaging;
import com.energyict.mdc.upl.messages.DeviceMessage;
import com.energyict.mdc.upl.messages.DeviceMessageSpec;
import com.energyict.mdc.upl.messages.OfflineDeviceMessage;
import com.energyict.mdc.upl.messages.legacy.DeviceMessageFileExtractor;
import com.energyict.mdc.upl.messages.legacy.KeyAccessorTypeExtractor;
import com.energyict.mdc.upl.messages.legacy.LoadProfileExtractor;
import com.energyict.mdc.upl.messages.legacy.NumberLookupExtractor;
import com.energyict.mdc.upl.messages.legacy.TariffCalendarExtractor;
import com.energyict.mdc.upl.meterdata.Device;
import com.energyict.mdc.upl.nls.NlsService;
import com.energyict.mdc.upl.offline.OfflineDevice;
import com.energyict.mdc.upl.properties.Converter;
import com.energyict.mdc.upl.properties.PropertySpec;
import com.energyict.mdc.upl.properties.PropertySpecService;
import com.energyict.protocolimplv2.messages.SecurityMessage;
import com.energyict.protocolimplv2.nta.abstractnta.messages.AbstractMessageExecutor;

import java.util.List;
import java.util.Optional;

/**
 * Note that the breaker control messages are not supported in this class.
 * Copyrights EnergyICT
 * Date: 19/04/13
 * Time: 17:07
 * Author: khe
 */
public class CryptoDSMR23Messaging extends Dsmr23Messaging {

    private CommonCryptoMessaging commonCryptoMessaging;

    public CryptoDSMR23Messaging(AbstractMessageExecutor messageExecutor, PropertySpecService propertySpecService,
                                 NlsService nlsService, Converter converter, DeviceMessageFileExtractor messageFileExtractor,
                                 TariffCalendarExtractor calendarExtractor, NumberLookupExtractor numberLookupExtractor,
                                 LoadProfileExtractor loadProfileExtractor, KeyAccessorTypeExtractor keyAccessorTypeExtractor) {
        super(messageExecutor, propertySpecService, nlsService, converter, messageFileExtractor, calendarExtractor,
              numberLookupExtractor, loadProfileExtractor, keyAccessorTypeExtractor);
        commonCryptoMessaging = new CommonCryptoMessaging(propertySpecService, nlsService, converter, keyAccessorTypeExtractor);
    }

    @Override
    public List<DeviceMessageSpec> getSupportedMessages() {
        List<DeviceMessageSpec> supportedMessages = super.getSupportedMessages();

        supportedMessages.add(this.get(SecurityMessage.CHANGE_AUTHENTICATION_KEY_USING_SERVICE_KEY_PROCESS));
        supportedMessages.add(this.get(SecurityMessage.CHANGE_ENCRYPTION_KEY_USING_SERVICE_KEY_PROCESS));
        supportedMessages.add(this.get(SecurityMessage.CHANGE_HLS_SECRET_USING_SERVICE_KEY_PROCESS));

        // remove messages not applicable to Crypto-HSM
        //  (we cannot just send a clear key to the meter, the new key needs to be generated by HSM)
        supportedMessages.remove(this.get(SecurityMessage.CHANGE_ENCRYPTION_KEY_WITH_NEW_KEY));
        supportedMessages.remove(this.get(SecurityMessage.CHANGE_AUTHENTICATION_KEY_WITH_NEW_KEY));

        return supportedMessages;
    }

    @Override
    public String format(OfflineDevice offlineDevice, OfflineDeviceMessage offlineDeviceMessage, PropertySpec propertySpec, Object messageAttribute) {
        String formattedString = commonCryptoMessaging.format(offlineDeviceMessage, propertySpec, messageAttribute);
        return formattedString == null ? super.format(offlineDevice, offlineDeviceMessage, propertySpec, messageAttribute) : formattedString;
    }

    @Override
    public Optional<String> prepareMessageContext(Device device, OfflineDevice offlineDevice, DeviceMessage deviceMessage) {
        String context = commonCryptoMessaging.prepareMessageContext(device, deviceMessage);
        return context == null ? super.prepareMessageContext(device, offlineDevice, deviceMessage) : Optional.ofNullable(context);
    }

}